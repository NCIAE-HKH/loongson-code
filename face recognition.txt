#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
人脸识别脚本 - 修复识别失败问题
解决注册后仍被识别为陌生人
"""

import cv2
import os
import numpy as np
import sys
import time
import logging
import socket
import pickle
import struct
import glob

# ==== 配置参数 =====
PROJECT_DIR = os.path.join(os.path.expanduser("~"), "projects/my_project")
CASCADE_PATH = os.path.join(PROJECT_DIR, "shared", "haarcascade_frontalface_default.xml")
TRAINER_PATH = os.path.join(PROJECT_DIR, "shared", "face_model.yml")
ID_MAP_PATH = os.path.join(PROJECT_DIR, "shared", "id_map.txt")
PC_IP = '192.168.1.166'  # PC端IP地址
PC_PORT = 8888            # PC端端口
ALARM_PATH = '/home/long2/audio/alarm.wav'  # 确保此文件存在

# ==== 配置日志 =====
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('FaceRecognition')

# ==== 关键修复 - 模型加载问题 =====
def load_models():
    """加载所有模型和映射 - 修复模型加载问题"""
    # 1. 加载人脸检测器
    try:
        detector = cv2.CascadeClassifier(CASCADE_PATH)
        if detector.empty():
            logger.error("检测器加载失败: %s", CASCADE_PATH)
            logger.info("请检查文件是否存在或下载: wget -P shared/ https://raw.githubusercontent.com/opencv/opencv/3.2.0/data/haarcascades/haarcascade_frontalface_default.xml")
            return None, None, None
    except Exception as e:
        logger.error("加载检测器失败: %s", str(e))
        return None, None, None
    
    # 2. 加载识别模型 - 兼容OpenCV 3.2.0
    try:
        # OpenCV 3.2.0专用API
        recognizer = cv2.face.createLBPHFaceRecognizer()
        
        if not os.path.exists(TRAINER_PATH):
            logger.error("模型文件不存在: %s", TRAINER_PATH)
            logger.info("请先运行人脸注册程序创建模型")
            return None, None, None
            
        recognizer.load(TRAINER_PATH)
    except Exception as e:
        logger.error("加载识别器失败: %s", str(e))
        return None, None, None
    
    # 3. 加载用户映射
    id_map = {}
    if os.path.exists(ID_MAP_PATH):
        try:
            with open(ID_MAP_PATH, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        parts = line.split(':')
                        if len(parts) >= 2:
                            id_val = int(parts[0])
                            username = ':'.join(parts[1:])
                            id_map[id_val] = username
                            logger.debug("加载用户映射: ID %d -> %s", id_val, username)
        except Exception as e:
            logger.error("加载ID映射失败: %s", str(e))
    
    return detector, recognizer, id_map

# ==== 关键修复 - 识别置信度处理 =====
def process_face(detector, recognizer, id_map, gray_frame, color_frame):
    """处理单个人脸并返回结果 - 修复置信度阈值问题"""
    # 默认结果
    result = "no_face"
    user_name = "Unknown"
    confidence_val = 100
    label_id = -1
    
    # 人脸检测
    faces = detector.detectMultiScale(
        gray_frame,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(60, 60)
    )
    
    if len(faces) > 0:
        # 取最大人脸
        (x, y, w, h) = max(faces, key=lambda f: f[2]*f[3])
        
        # 裁剪人脸区域
        face_roi = gray_frame[y:y+h, x:x+w]
        
        # 关键改进1: 统一尺寸为训练时的大小
        face_roi = cv2.resize(face_roi, (100, 100))
        
        # 识别人脸
        label_id, confidence_val = recognizer.predict(face_roi)
        
        # 关键改进2: 优化置信度阈值 - 针对您的69.6进行调整
        # OpenCV LBPH识别器的置信度通常: 
        #   0-50: 高匹配
        #   50-70: 中等匹配
        #   70+: 低匹配/陌生人
        if confidence_val < 70:  # 调整阈值以适应您的场景
            result = "known"
            user_name = id_map.get(label_id, f"ID {label_id}")
        else:
            result = "stranger"
            user_name = "Unknown"
        
        # 在帧上标记结果
        color = (0, 255, 0) if result == "known" else (0, 0, 255)
        cv2.rectangle(color_frame, (x, y), (x+w, y+h), color, 2)
        status_text = f"{user_name} ({confidence_val:.1f})" if result == "known" else f"Unknown ({confidence_val:.1f})"
        cv2.putText(color_frame, status_text, (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 1)
    
    return result, user_name, confidence_val, color_frame

# ==== 识别主函数 =====
def recognize_and_send():
    """人脸识别并发送结果到PC - 增强版"""
    # 加载模型
    detector, recognizer, id_map = load_models()
    if not detector or not recognizer:
        logger.error("模型加载失败，无法继续")
        return
    
    # 显示加载的用户映射
    if id_map:
        logger.info("已加载用户映射: %d个用户", len(id_map))
        for uid, name in id_map.items():
            logger.info("- ID %d: %s", uid, name)
    else:
        logger.warning("未加载用户映射文件，将无法显示用户名")
    
    # 连接PC端
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((PC_IP, PC_PORT))
        logger.info("已连接到PC端: %s:%d", PC_IP, PC_PORT)
    except Exception as e:
        logger.error("无法连接到PC: %s", str(e))
        return
    
    # 打开摄像头
    try:
        # 查找最佳摄像头设备
        possible_devices = glob.glob("/dev/video*")
        camera_index = 0
        
        if possible_devices:
            logger.info("找到摄像头设备: %s", ", ".join(possible_devices))
            # 尝试video0
            if "/dev/video0" in possible_devices:
                camera_index = 0
            else:
                camera_index = int(possible_devices[0].replace("/dev/video", ""))
        
        cap = cv2.VideoCapture(camera_index)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        
        if not cap.isOpened():
            logger.error("无法打开摄像头")
            sock.close()
            return
    except Exception as e:
        logger.error("摄像头初始化失败: %s", str(e))
        sock.close()
        return
    
    logger.info("开始人脸识别...按Ctrl+C停止")
    
    last_alarm_time = 0
    alarm_cooldown = 5  # 警报冷却时间(秒)
    
    try:
        while True:
            # 读取帧
            ret, color_frame = cap.read()
            if not ret:
                logger.warning("读取摄像头失败")
                time.sleep(0.1)
                continue
            
            # 转换为灰度图
            gray_frame = cv2.cvtColor(color_frame, cv2.COLOR_BGR2GRAY)
            
            # 处理人脸
            result, user_name, confidence_val, result_frame = process_face(
                detector, recognizer, id_map, gray_frame, color_frame
            )
            
            # 如果是陌生人且冷却时间已过，触发警报
            if result == "stranger" and time.time() - last_alarm_time > alarm_cooldown:
                logger.warning("检测到陌生人! 置信度: %.2f", confidence_val)
                if os.path.exists(ALARM_PATH):
                    try:
                        os.system(f"aplay {ALARM_PATH} &")
                    except:
                        pass
                last_alarm_time = time.time()
            
            # 压缩图像
            _, jpeg = cv2.imencode('.jpg', result_frame)
            frame_data = jpeg.tobytes()
            
            # 创建数据包
            data_packet = {
                'result': result,
                'user_name': user_name,
                'confidence': confidence_val,
                'frame_data': frame_data
            }
            
            # 序列化并发送
            try:
                serialized_data = pickle.dumps(data_packet)
                message_size = struct.pack(">L", len(serialized_data))
                sock.sendall(message_size + serialized_data)
            except Exception as e:
                logger.error("网络发送错误: %s", str(e))
                break
            
            # 控制帧率
            time.sleep(0.05)
            
    except KeyboardInterrupt:
        logger.info("用户停止识别")
    except Exception as e:
        logger.error("识别过程中出错: %s", str(e))
    finally:
        cap.release()
        sock.close()
        logger.info("资源已释放")

# ==== 主程序入口 ====
if __name__ == "__main__":
    print("\n" + "=" * 50)
    print("人脸识别监控 - 设备端 (修复版)")
    print("=" * 50)
    
    # 显示关键路径
    logger.info("项目目录: %s", PROJECT_DIR)
    logger.info("模型文件: %s", TRAINER_PATH)
    logger.info("映射文件: %s", ID_MAP_PATH)
    logger.info("连接目标: %s:%d", PC_IP, PC_PORT)
    
    # 执行识别
    recognize_and_send()
    
    print("\n程序结束")


