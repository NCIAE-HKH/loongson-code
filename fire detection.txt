import cv2
import socket
import time
import numpy as np
import logging
import os
import struct
import sys
import subprocess
from datetime import datetime

# =====================================================
# 请修改为PC的实际IP地址 (使用192.168.1.243)
PC_IP = '192.168.1.166'  # PC的IP
PORT = 80  # 使用80端口
LOG_DIR = "/home/long2/logs/"
MAX_RETRIES = 20
FRAME_WIDTH = 640
FRAME_HEIGHT = 480
FRAME_RATE = 15  # 帧率
SEND_TIMEOUT = 3
QUALITY = 75  # 图像质量
ALERT_SOUND_FILE = "/home/long2/alarm.wav"  # 设备端报警声音文件路径
ALERT_COOLDOWN = 10  # 报警冷却时间(秒)

# =====================================================================================================
os.makedirs(LOG_DIR, exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s-%(name)s-%(levelname)s-%(message)s',
    handlers=[
        logging.FileHandler(os.path.join(LOG_DIR, "device.log")),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("FireDetectionDevice")

# ================== 高灵敏度火焰检测器（打火机专用）
class FireDetector:
    def __init__(self):
        # 检测OpenCV版本
        self.opencv_version = cv2.__version__
        self.opencv_major = int(self.opencv_version.split('.')[0])
        logger.info(f"OpenCV版本: {self.opencv_version} (主要版本{self.opencv_major})")
        
        # 火焰检测参数
        self.min_fire_area = 30  # 降低最小面积要求（打火机火焰较小）
        self.fire_score = 0  # 火焰综合评分
        self.consecutive_fire_frames = 0  # 连续检测到火焰的帧数
        
        # 打火机火焰颜色范围（黄色、橙色、红色、蓝色核心）
        self.lower_yellow = np.array([15, 120, 150])
        self.upper_yellow = np.array([35, 255, 255])
        self.lower_orange = np.array([5, 150, 150])
        self.upper_orange = np.array([18, 255, 255])
        self.lower_red = np.array([0, 150, 100])
        self.upper_red = np.array([5, 255, 255])
        self.lower_blue = np.array([95, 50, 50])  # 打火机核心的蓝色火焰
        self.upper_blue = np.array([120, 255, 255])
        
        # 亮度阈值（火焰中心通常最亮）
        self.min_brightness = 180  # 火焰区域最小亮度阈值
        
        # 历史帧用于运动检测
        self.prev_gray = None
        self.prev_fire_mask = None
        self.last_flame_points = []
        self.prev_roi = None  # 用于运动特征

    def get_contours(self, binary_image):
        """兼容所有OpenCV版本的轮廓获取函数"""
        # OpenCV 3.x: 返回三个值 (image, contours, hierarchy)
        if self.opencv_major == 3:
            _, contours, _ = cv2.findContours(
                binary_image, 
                cv2.RETR_EXTERNAL, 
                cv2.CHAIN_APPROX_SIMPLE
            )
        # OpenCV 4.x: 返回两个值 (contours, hierarchy)
        else:
            contours, _ = cv2.findContours(
                binary_image, 
                cv2.RETR_EXTERNAL, 
                cv2.CHAIN_APPROX_SIMPLE
            )
        return contours
    
    def calc_lbp_fast(self, image):
        """快速LBP实现（只计算4个方向）"""
        lbp = np.zeros_like(image, dtype=np.uint8)
        h, w = image.shape
        for i in range(1, h-1):
            for j in range(1, w-1):
                center = image[i, j]
                code = 0
                # 只计算4个方向（上、右、下、左）
                code |= (image[i-1, j] > center) << 0
                code |= (image[i, j+1] > center) << 1
                code |= (image[i+1, j] > center) << 2
                code |= (image[i, j-1] > center) << 3
                lbp[i, j] = code
        return lbp

    def extract_features(self, roi):
        """提取火焰候选区域的特征向量"""
        features = []
        
        # 1. 颜色特征（HSV空间）
        hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        h_mean = np.mean(hsv[:, :, 0])
        s_mean = np.mean(hsv[:, :, 1])
        v_mean = np.mean(hsv[:, :, 2])
        features.extend([h_mean, s_mean, v_mean])
        
        # 2. 纹理特征（LBP）- 使用简化版本
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        lbp = self.calc_lbp_fast(gray)
        hist, _ = np.histogram(lbp.ravel(), bins=8, range=(0, 256))
        hist = hist / hist.sum()  # 归一化
        features.extend(hist.tolist())
        
        # 3. 形状特征（宽高比）
        height, width = roi.shape[:2]
        aspect_ratio = width / height if height != 0 else 0
        features.append(aspect_ratio)
        
        # 4. 运动特征（与前一帧的差异）
        if self.prev_roi is not None and self.prev_roi.shape == roi.shape:
            diff = cv2.absdiff(roi, self.prev_roi)
            diff_mean = np.mean(diff)
            features.append(diff_mean)
        else:
            features.append(0)
        
        self.prev_roi = roi.copy()
        return np.array(features, dtype=np.float32)

    def detect(self, frame):
        # 转换为HSV颜色空间
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        # 创建复合火焰掩膜（针对打火机火焰）
        mask_yellow = cv2.inRange(hsv, self.lower_yellow, self.upper_yellow)
        mask_orange = cv2.inRange(hsv, self.lower_orange, self.upper_orange)
        mask_red = cv2.inRange(hsv, self.lower_red, self.upper_red)
        mask_blue = cv2.inRange(hsv, self.lower_blue, self.upper_blue)  # 打火机核心蓝色火焰
        
        # 融合多个颜色掩膜
        color_mask = cv2.bitwise_or(mask_yellow, mask_orange)
        color_mask = cv2.bitwise_or(color_mask, mask_red)
        color_mask = cv2.bitwise_or(color_mask, mask_blue)
        
        # 形态学处理（增强小火焰连通性）
        kernel = np.ones((3, 3), np.uint8)
        fire_mask = cv2.morphologyEx(color_mask, cv2.MORPH_OPEN, kernel)
        fire_mask = cv2.dilate(fire_mask, kernel, iterations=1)
        
        # 亮度过滤 - 火焰通常是高亮区域
        _, brightness_mask = cv2.threshold(gray, self.min_brightness, 255, cv2.THRESH_BINARY)
        fire_mask = cv2.bitwise_and(fire_mask, brightness_mask)
        
        # 获取轮廓（使用兼容方法）
        contours = self.get_contours(fire_mask)
        
        fire_detected = False
        max_area = 0
        current_flame_points = []
        candidate_regions = []
        
        # 分析每个火焰候选区域
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area < self.min_fire_area:
                continue
                
            # 记录最大火焰面积
            max_area = max(max_area, area)
            
            # 火焰形状分析
            rect = cv2.boundingRect(cnt)
            aspect_ratio = float(rect[2]) / rect[3] if rect[3] != 0 else 0
            
            # 火焰核心区域亮度分析
            x, y, w, h = rect
            roi = gray[y:y+h, x:x+w]
            max_brightness = np.max(roi)
            avg_brightness = np.mean(roi)
            
            # 打火机火焰特性：高亮度、细长形状
            if max_brightness > 200 and 0.3 < aspect_ratio < 3.0:
                fire_detected = True
                center = (rect[0] + rect[2] // 2, rect[1] + rect[3] // 2)
                current_flame_points.append(center)
                candidate_regions.append((x, y, w, h))
                
                # 在图像上标记火焰（红色矩形）
                cv2.rectangle(frame, (rect[0], rect[1]),
                            (rect[0] + rect[2], rect[1] + rect[3]),
                            (0, 0, 255), 2)
                
                # 在图像上显示火焰信息
                cv2.putText(frame, f"Area: {area}", (rect[0], rect[1]-10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
                cv2.putText(frame, f"Bright: {max_brightness}", (rect[0], rect[1]-30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
        
        # 火焰动态检测（关键优化）
        motion_score = 0
        brightness_change = 0
        
        if fire_detected and self.prev_gray is not None:
            # 1. 计算亮度变化
            current_avg_brightness = np.mean(gray)
            prev_avg_brightness = np.mean(self.prev_gray)
            brightness_change = abs(current_avg_brightness - prev_avg_brightness) / 255.0
            
            # 2. 计算运动变化（火焰中心点移动）
            if self.last_flame_points:
                movement = 0
                for pt in current_flame_points:
                    min_dist = min([np.sqrt((pt[0]-lp[0])**2 + (pt[1]-lp[1])**2) 
                                   for lp in self.last_flame_points], default=5)
                    movement += min_dist
                motion_score = min(1.0, movement / (50 * len(current_flame_points)))
        
        # 火焰分数计算
        if fire_detected:
            # 火焰分数 = 区域大小(40%) + 运动(30%) + 亮度变化(30%)
            area_score = min(1.0, max_area / 300.0)
            motion_score_val = min(1.0, motion_score * 3.0)
            brightness_score = min(1.0, brightness_change * 3.0)
            current_score = area_score * 0.4 + motion_score_val * 0.3 + brightness_score * 0.3
            
            # 更新火焰分数（指数平滑）
            self.fire_score = min(1.0, self.fire_score * 0.7 + current_score * 0.3)
            
            # 连续检测到火焰的帧数
            self.consecutive_fire_frames += 1
            
            # 显示动态信息
            cv2.putText(frame, f"Fire Score: {self.fire_score:.2f}", (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            cv2.putText(frame, f"Motion: {motion_score:.2f}", (10, 60),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            cv2.putText(frame, f"Bright: {brightness_change:.2f}", (10, 90),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            cv2.putText(frame, f"Frames: {self.consecutive_fire_frames}", (10, 120),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        else:
            # 没有火焰时降低分数
            self.fire_score = max(0, self.fire_score * 0.8 - 0.05)
            self.consecutive_fire_frames = 0
        
        # 保存当前状态用于下一帧
        self.prev_gray = gray.copy()
        self.last_flame_points = current_flame_points
        
        # 最终决策：只有动态火焰才触发警报
        if fire_detected and self.fire_score > 0.4 and self.consecutive_fire_frames >= 2:
            # 突出显示报警
            cv2.putText(frame, "FLAME DETECTED!", (frame.shape[1]//2-100, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 3)
            return frame, True, candidate_regions
        else:
            return frame, False, candidate_regions

# =================== 报警声音管理
class AlertPlayer:
    def __init__(self, sound_file):
        self.sound_file = sound_file
        self.last_played = 0
    
    def play(self):
        try:
            if time.time() - self.last_played < ALERT_COOLDOWN:
                return
            subprocess.Popen(["aplay", self.sound_file])
            self.last_played = time.time()
            return True
        except Exception as e:
            logger.error(f"播放报警失败: {str(e)}")
            return False

# =====================================================================================================
class NetworkManager:
    def __init__(self):
        self.host = PC_IP
        self.port = PORT
        self.socket = None
        self.retries = 0
        self.max_retries = MAX_RETRIES
        self.frame_header_size = 4
        self.connection_active = False
    
    def connect(self):
        self.retries = 0
        while self.retries < self.max_retries:
            try:
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((self.host, self.port))
                logger.info(f"已连接到服务器: {self.host}:{self.port}")
                self.retries = 0
                self.connection_active = True
                return True
            except socket.error as e:
                self.retries += 1
                wait_time = min(2 ** self.retries, 30)
                logger.warning(f"连接失败 ({self.retries}/{self.max_retries}): {e}, 将在{wait_time}s后重试")
                time.sleep(wait_time)
        logger.error(f"{self.max_retries}次重试后连接失败")
        return False
    
    def send_frame(self, frame):
        if not self.connection_active:
            if not self.connect():
                return False
        
        try:
            # 压缩图像 (OpenCV兼容处理)
            result = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, QUALITY])
            
            # OpenCV版本兼容处理
            if isinstance(result, tuple) and len(result) >= 2:
                # OpenCV 3.x格式: (success, buffer)
                success, img_buffer = result
            else:
                # OpenCV 4.x格式
                success = True
                img_buffer = result
            
            if success:
                frame_data = img_buffer.tobytes()
                header = struct.pack('>L', len(frame_data))
                self.socket.sendall(header + frame_data)
                return True
            return False
        except Exception as e:
            logger.error(f"发送帧失败: {str(e)}")
            self.close_socket()
            return False
    
    def send_features(self, features):
        """发送火焰特征向量到PC端"""
        if not self.connection_active:
            return False
        
        try:
            # 序列化特征向量
            feature_data = features.tobytes()
            header = struct.pack('>L', len(feature_data))
            self.socket.sendall(header + feature_data)
            return True
        except Exception as e:
            logger.error(f"发送特征失败: {str(e)}")
            return False
    
    def send_alert(self):
        if not self.connection_active:
            return False
        try:
            alert_msg = f"FIRE_ALERT|{datetime.now().isoformat()}|检测到火焰!".encode()
            header = struct.pack('>L', len(alert_msg))
            self.socket.sendall(header + alert_msg)
            return True
        except Exception as e:
            logger.error(f"发送警报失败: {str(e)}")
            return False
    
    def close_socket(self):
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            self.socket = None
            self.connection_active = False
    
    def close(self):
        self.close_socket()
        logger.info("网络连接已关闭")

# =====================================================================================================
def main():
    logger.info("启动火焰检测设备")
    logger.info(f"设备IP: 192.168.1.162")
    
    # 初始化摄像头
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        logger.error("摄像头打开失败，正在重试...")
        for _ in range(3):
            cap = cv2.VideoCapture(0)
            if cap.isOpened():
                break
            time.sleep(2)
        else:
            logger.error("摄像头无法访问，程序退出")
            return
    
    # 设置摄像头参数
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
    cap.set(cv2.CAP_PROP_FPS, FRAME_RATE)
    
    # 初始化组件
    fire_detector = FireDetector()
    network = NetworkManager()
    alert_player = AlertPlayer(ALERT_SOUND_FILE)
    
    # 状态变量
    last_alert_time = 0
    frame_count = 0
    start_time = time.time()
    last_frame_time = time.time()
    feature_buffer = []
    
    # 绑定到单个CPU核心（龙芯优化）
    try:
        import os
        os.sched_setaffinity(0, {0})
        logger.info("已绑定到CPU核心0")
    except:
        logger.warning("CPU核心绑定失败，继续运行")
    
    try:
        while True:
            current_time = time.time()
            elapsed = current_time - last_frame_time
            
            # 控制帧率
            if elapsed < 1.0 / FRAME_RATE:
                time.sleep(max(0, (1.0 / FRAME_RATE) - elapsed - 0.001))
                continue
            
            last_frame_time = current_time
            
            # 读取帧
            ret, frame = cap.read()
            if not ret:
                logger.warning("帧读取失败，跳过此帧")
                time.sleep(0.1)
                continue
            
            # 火焰检测（核心功能）
            processed_frame, fire_detected, candidates = fire_detector.detect(frame)
            
            # 提取特征并发送
            if fire_detected and candidates:
                # 取最大的候选区域
                largest_candidate = max(candidates, key=lambda c: c[2]*c[3])
                x, y, w, h = largest_candidate
                roi = frame[y:y+h, x:x+w]
                
                if roi.size > 0:
                    # 提取特征
                    features = fire_detector.extract_features(roi)
                    feature_buffer.append(features)
                    
                    # 每3帧发送一次特征（减少带宽）
                    if len(feature_buffer) >= 3:
                        # 取平均值作为特征向量
                        avg_features = np.mean(feature_buffer, axis=0)
                        network.send_features(avg_features)
                        feature_buffer = []
            
            # 发送帧到PC端
            network.send_frame(processed_frame)
            
            # 处理火焰警报
            if fire_detected:
                if (current_time - last_alert_time) > ALERT_COOLDOWN:
                    logger.warning("检测到火焰！触发警报")
                    
                    # 播放警报声
                    alert_player.play()
                    
                    # 发送警报到PC
                    network.send_alert()
                    
                    # 保存证据
                    save_path = f"{LOG_DIR}/alert_{int(current_time)}.jpg"
                    cv2.imwrite(save_path, frame)
                    logger.info(f"保存警报图片: {save_path}")
                    
                    last_alert_time = current_time
            
            # 性能监控
            frame_count += 1
            if frame_count % 50 == 0:
                elapsed_time = current_time - start_time
                if elapsed_time > 0:
                    fps = frame_count / elapsed_time
                    status = f"运行中 - FPS: {fps:.1f}, 火焰评分: {fire_detector.fire_score:.2f}"
                    logger.info(status)
            
            # 网络自动重连
            if frame_count % 10 == 0 and not network.connection_active:
                network.connect()
    
    except KeyboardInterrupt:
        logger.info("用户中断程序")
    except Exception as e:
        logger.critical(f"未处理异常: {str(e)}")
    finally:
        cap.release()
        network.close()
        logger.info("设备关闭")
        sys.exit(0)

if __name__ == "__main__":
main()


