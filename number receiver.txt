import socket
import struct
import time
import logging
import threading
import tkinter as tk
from tkinter import ttk, messagebox
import queue
from PIL import Image, ImageTk, ImageDraw, ImageFont
import sys
import numpy as np
import io  # 确保导入io模块

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger()

# 设备端IP设置 - 根据实际情况修改
DEVICE_IP = '192.168.1.162'  # 使用截图中的设备IP
VIDEO_PORT = 5002
ALARM_PORT = 5003
THRESHOLD_PORT = 5004

# 视频帧队列
frame_queue = queue.Queue(maxsize=3)

# ==== 修复关键点：添加图像解码函数定义 ====
def decode_image_with_pil(data):
    """使用PIL解码图像数据"""
    try:
        return Image.open(io.BytesIO(data))
    except Exception as e:
        logger.error(f"PIL图像解码失败: {str(e)}")
        # 创建黑色图像作为备用
        return Image.new('RGB', (640, 480), (0, 0, 0))
# ==== 修复结束 ====

class SecurityApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("工业安防监控系统")
        self.geometry("1100x750")
        self.refresh_active = True
        
        # 全局变量
        self.video_connected = False
        self.alarm_connected = False
        self.last_frame_time = 0
        self.frame_counter = 0
        self.current_count = 0
        self.display_image = None
        self.after_id = None
        
        # 创建UI
        self.create_ui()
        
        # 启动后台线程
        self.start_threads()
        
        # 启动视频刷新
        self.start_refresh()
        
        # 状态更新
        self.update_status()
        
        # 窗口关闭处理
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_ui(self):
        """创建UI界面"""
        # 主容器
        main_frame = ttk.Frame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # 顶部状态栏
        self.status_var = tk.StringVar(value="系统初始化中...")
        status_bar = ttk.Frame(main_frame, height=30, relief="ridge")
        status_bar.pack(fill="x", pady=5)
        
        ttk.Label(status_bar, textvariable=self.status_var, padding=5).pack(side="left")
        
        # 帧率显示
        self.fps_var = tk.StringVar(value="0 FPS")
        ttk.Label(status_bar, textvariable=self.fps_var, padding=5).pack(side="right")
        
        # 主内容区域（视频+控制）
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill="both", expand=True)
        
        # 视频显示区域
        video_frame = ttk.LabelFrame(content_frame, text="监控画面", padding=10)
        video_frame.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        # 使用Canvas显示视频
        self.canvas = tk.Canvas(video_frame, bg="black", bd=0, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        
        # 控制面板区域
        control_frame = ttk.LabelFrame(content_frame, text="参数控制", padding=15)
        control_frame.pack(side="left", fill="y", padx=5, pady=5)
        
        # 人数显示区域
        count_frame = ttk.Frame(control_frame, padding=10)
        count_frame.pack(fill="x", pady=10)
        
        ttk.Label(count_frame, text="当前人数:", font=("Arial", 12)).pack(side="left")
        self.count_var = tk.StringVar(value="0")
        ttk.Label(count_frame, textvariable=self.count_var, font=("Arial", 16, "bold"), 
                 foreground="red").pack(side="left", padx=5)
        
        # 阈值控制区域
        ttk.Label(control_frame, text="上限阈值:").pack(anchor="w", padx=5, pady=(10, 0))
        self.upper_threshold = tk.IntVar(value=10)
        ttk.Scale(control_frame, from_=1, to=20, orient="horizontal",
                 variable=self.upper_threshold,
                 command=self.on_slider_change,
                 length=200).pack(fill="x", padx=10, pady=5)
        ttk.Label(control_frame, textvariable=self.upper_threshold).pack(anchor="e", padx=15)
        
        ttk.Label(control_frame, text="下限阈值:").pack(anchor="w", padx=5, pady=(15, 0))
        self.lower_threshold = tk.IntVar(value=1)
        ttk.Scale(control_frame, from_=0, to=10, orient="horizontal",
                 variable=self.lower_threshold,
                 command=self.on_slider_change,
                 length=200).pack(fill="x", padx=10, pady=5)
        ttk.Label(control_frame, textvariable=self.lower_threshold).pack(anchor="e", padx=15)
        
        # 更新按钮
        self.update_btn = ttk.Button(control_frame, text="更新阈值", 
                                    command=self.send_thresholds,
                                    state="disabled")
        self.update_btn.pack(pady=15, padx=10, ipadx=10)
        
        # 报警状态
        self.alarm_var = tk.StringVar(value="系统正常运行中")
        alarm_frame = ttk.Frame(control_frame, padding=10)
        alarm_frame.pack(fill="x", pady=10)
        
        ttk.Label(alarm_frame, text="报警状态:", font=("Arial", 10)).pack(side="left")
        self.alarm_label = ttk.Label(alarm_frame, textvariable=self.alarm_var, 
                                    font=("Arial", 10), foreground="green")
        self.alarm_label.pack(side="left", padx=5)
        
        # 底部状态栏
        footer_frame = ttk.Frame(main_frame, height=30, relief="sunken")
        footer_frame.pack(fill="x", padx=5, pady=5)
        
        self.footer_var = tk.StringVar(value="等待连接设备端...")
        ttk.Label(footer_frame, textvariable=self.footer_var, padding=5).pack(side="left")
    
    def on_slider_change(self, event):
        """滑块改变时启用更新按钮"""
        self.update_btn.config(state="normal")
    
    def send_thresholds(self):
        """发送阈值到设备端"""
        try:
            upper = self.upper_threshold.get()
            lower = self.lower_threshold.get()
            
            if lower >= upper:
                self.alarm_var.set("错误: 下限不能大于等于上限")
                return
                
            thresholds = f"{upper},{lower}".encode()
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3.0)
            try:
                sock.connect((DEVICE_IP, THRESHOLD_PORT))
                sock.sendall(thresholds)
                self.update_btn.config(state="disabled")
                self.alarm_var.set("阈值已更新")
                logger.info(f"已发送阈值: {upper},{lower}")
            except Exception as e:
                self.alarm_var.set(f"发送失败: {e.__class__.__name__}")
                logger.error(f"发送阈值错误: {e}")
            finally:
                try:
                    sock.close()
                except:
                    pass
        except Exception as e:
            self.alarm_var.set(f"设置错误: {e.__class__.__name__}")
            logger.error(f"阈值设置错误: {e}")
    
    def update_status(self):
        """更新状态栏信息"""
        video_status = "已连接" if self.video_connected else "未连接"
        alarm_status = "已连接" if self.alarm_connected else "未连接"
        self.footer_var.set(
            f"设备端: {DEVICE_IP} | 视频流: {video_status} | 报警状态: {alarm_status}")
        
        # 每2秒更新一次
        if self.refresh_active:
            self.after(2000, self.update_status)
    
    def start_threads(self):
        """启动后台线程"""
        # 视频接收线程
        video_thread = threading.Thread(target=self.receive_video, name="VideoReceiver", daemon=True)
        video_thread.start()
        
        # 报警处理线程
        alarm_thread = threading.Thread(target=self.handle_alarms, name="AlarmHandler", daemon=True)
        alarm_thread.start()
    
    def receive_video(self):
        """接收视频流数据"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            sock.bind(('0.0.0.0', VIDEO_PORT))
            sock.listen(1)
            self.status_var.set("等待设备连接...")
            logger.info("视频服务启动")
            
            while self.refresh_active:
                try:
                    conn, addr = sock.accept()
                    self.video_connected = True
                    self.status_var.set(f"视频连接: {addr[0]}")
                    logger.info(f"设备已连接: {addr}")
                    
                    data = b""
                    header_size = struct.calcsize("!III")  # 帧大小(4B) + 帧号(4B) + 人数(4B)
                    connection_active = True
                    
                    while connection_active and self.refresh_active:
                        try:
                            # 1. 读取帧头
                            while len(data) < header_size:
                                chunk = conn.recv(4096)
                                if not chunk:
                                    raise ConnectionError("连接断开")
                                data += chunk
                            
                            # 2. 解包帧头
                            header_data = data[:header_size]
                            data = data[header_size:]
                            
                            # 解包格式：帧大小(4B), 帧号(4B), 人数(4B)
                            frame_size, frame_num, person_count = struct.unpack("!III", header_data)
                            self.current_count = person_count
                            self.count_var.set(str(person_count))
                            
                            # 3. 读取图像数据
                            while len(data) < frame_size:
                                chunk = conn.recv(4096)
                                if not chunk:
                                    raise ConnectionError("连接断开")
                                data += chunk
                            
                            frame_data = data[:frame_size]
                            data = data[frame_size:]
                            
                            # ==== 修复关键点：使用正确的图像解码函数 ====
                            # 4. 解码图像
                            try:
                                img = decode_image_with_pil(frame_data)
                                
                                # 转换为RGB格式
                                if img.mode != 'RGB':
                                    img = img.convert('RGB')
                                
                                # 转换为NumPy数组
                                img_np = np.array(img)
                            except Exception as e:
                                logger.error(f"图像处理错误: {str(e)}")
                                # 创建黑色图像替代
                                img_np = np.zeros((480, 640, 3), dtype=np.uint8)
                            
                            # 添加到队列
                            try:
                                if frame_queue.full():
                                    frame_queue.get_nowait()
                                frame_queue.put(img_np)
                            except queue.Full:
                                pass
                            except Exception as e:
                                logger.error(f"队列处理错误: {e}")
                        
                        except (ConnectionError, BrokenPipeError) as e:
                            self.video_connected = False
                            self.status_var.set("视频连接丢失")
                            logger.warning(f"视频连接断开: {str(e)}")
                            connection_active = False
                            
                        except Exception as e:
                            logger.error(f"视频处理错误: {str(e)}")
                            self.video_connected = False
                            self.status_var.set("视频处理错误")
                            connection_active = False
                    
                    # 关闭当前连接
                    try:
                        conn.close()
                    except:
                        pass
                    
                    self.video_connected = False
                    self.status_var.set("等待重连...")
                    time.sleep(3)
                    
                except Exception as e:
                    logger.error(f"接收连接错误: {str(e)}")
                    time.sleep(5)
                    
        except Exception as e:
            logger.critical(f"视频服务崩溃: {str(e)}")
            self.status_var.set("视频服务不可用")
        finally:
            try:
                sock.close()
            except:
                pass
    
    def handle_alarms(self):
        """处理报警连接"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            sock.bind(('0.0.0.0', ALARM_PORT))
            sock.listen(1)
            
            while self.refresh_active:
                try:
                    conn, addr = sock.accept()
                    self.alarm_connected = True
                    logger.info(f"报警连接: {addr}")
                    
                    while self.refresh_active:
                        try:
                            # 读取报警数据大小
                            size_data = conn.recv(4)
                            if not size_data:
                                raise ConnectionError("连接断开")
                            
                            if len(size_data) == 4:
                                size = struct.unpack("!I", size_data)[0]
                                
                                # 读取实际报警数据
                                alarm_data = b""
                                while len(alarm_data) < size:
                                    chunk = conn.recv(size - len(alarm_data))
                                    if not chunk:
                                        raise ConnectionError("连接断开")
                                    alarm_data += chunk
                                
                                # 解析报警信息
                                try:
                                    alarm_str = alarm_data.decode()
                                    if ',' in alarm_str:
                                        parts = alarm_str.split(',')
                                        timestamp = parts[0]
                                        alarm_type = parts[1] if len(parts) > 1 else "UNKNOWN"
                                        count = parts[2] if len(parts) > 2 else "0"
                                        
                                        # 更新UI
                                        self.alarm_var.set(f"{timestamp} - {alarm_type} ({count}人)")
                                        
                                        # 设置报警颜色
                                        if alarm_type == "OVER":
                                            self.alarm_label.config(foreground="red")
                                        elif alarm_type == "UNDER":
                                            self.alarm_label.config(foreground="orange")
                                        else:
                                            self.alarm_label.config(foreground="green")
                                except Exception as e:
                                    logger.warning(f"解析报警数据失败: {str(e)}")
                            
                        except (ConnectionError, BrokenPipeError):
                            self.alarm_connected = False
                            break
                        except Exception as e:
                            logger.warning(f"报警接收错误: {str(e)}")
                            break
                    
                    try:
                        conn.close()
                    except:
                        pass
                    time.sleep(1)
                
                except Exception as e:
                    logger.error(f"报警服务错误: {str(e)}")
                    time.sleep(5)
                    
        except Exception as e:
            logger.critical(f"报警服务崩溃: {str(e)}")
        finally:
            try:
                sock.close()
            except:
                pass
    
    def start_refresh(self):
        """启动视频刷新循环"""
        if not self.after_id and self.refresh_active:
            self.after_id = self.after(20, self.refresh_video)
    
    def refresh_video(self):
        """安全更新视频画面"""
        try:
            if not frame_queue.empty():
                # 获取最新帧
                img = frame_queue.get()
                
                # 确保图像是NumPy数组
                if not isinstance(img, np.ndarray):
                    logger.warning("收到非NumPy数组类型的帧数据，尝试转换")
                    try:
                        if isinstance(img, Image.Image):
                            img = np.array(img)
                        else:
                            raise ValueError("无法识别的图像格式")
                    except:
                        img = np.zeros((480, 640, 3), dtype=np.uint8)
                
                # 确保图像有正确的尺寸
                if img.shape[0] < 100 or img.shape[1] < 100:
                    logger.warning(f"图像尺寸过小: {img.shape}, 使用默认图像替代")
                    img = np.zeros((480, 640, 3), dtype=np.uint8)
                
                # 确保图像有正确的通道数
                if len(img.shape) == 2:  # 灰度图
                    img = np.stack((img,)*3, axis=-1)
                elif img.shape[2] == 1:  # 单通道
                    img = np.concatenate([img]*3, axis=2)
                elif img.shape[2] == 4:  # RGBA
                    img = img[..., :3]  # 丢弃Alpha通道
                
                # 获取Canvas尺寸
                canvas_width = self.canvas.winfo_width()
                canvas_height = self.canvas.winfo_height()
                
                if canvas_width > 0 and canvas_height > 0:
                    # 转换为PIL图像
                    pil_img = Image.fromarray(img)
                    
                    # 保持宽高比缩放
                    img_w, img_h = pil_img.size
                    scale = min(canvas_width / img_w, canvas_height / img_h)
                    new_width = int(img_w * scale)
                    new_height = int(img_h * scale)
                    
                    # 缩放图像
                    pil_img = pil_img.resize((new_width, new_height), Image.LANCZOS)
                    
                    # 转换为PhotoImage
                    self.display_image = ImageTk.PhotoImage(pil_img)
                    
                    # 更新Canvas
                    self.canvas.delete("all")
                    self.canvas.create_image(canvas_width//2, canvas_height//2, 
                                            image=self.display_image, anchor="center")
                    
                    # 添加人数显示
                    self.canvas.create_text(20, 20, text=f"人数: {self.current_count}", 
                                          font=("Arial", 16, "bold"), 
                                          fill="red", anchor="nw")
                    
                    # 计算帧率
                    now = time.time()
                    if self.last_frame_time > 0:
                        fps = 1 / (now - self.last_frame_time)
                        self.fps_var.set(f"{fps:.1f} FPS")
                    self.last_frame_time = now
            
        except Exception as e:
            logger.error(f"刷新视频错误: {str(e)}")
            self.status_var.set("视频渲染错误")
        
        # 重启刷新循环
        if self.refresh_active:
            self.after_id = self.after(20, self.refresh_video)
    
    def on_closing(self):
        """关闭窗口时的清理"""
        if messagebox.askokcancel("退出", "确定要关闭监控系统吗?"):
            logger.info("用户关闭程序")
            self.refresh_active = False  # 停止刷新循环
            
            # 取消所有定时任务
            if self.after_id:
                self.after_cancel(self.after_id)
            
            self.destroy()
            sys.exit(0)

if __name__ == "__main__":
    # 启动应用
    app = SecurityApp()
    app.mainloop()

