import cv2
import numpy as np
import socket
import struct
import time
import logging
import atexit
import sys
import os
from threading import Thread, Lock
import math
from collections import deque

# ------------ 全局变量初始化 ------------
# 摄像头对象
cap = None
# 网络连接
video_sock = None
alarm_sock = None
threshold_sock = None
# 状态参数
alarm_threshold_upper = 10
alarm_threshold_lower = 1
alarm_active = False
alarm_type = ""
frame_counter = 0
# 状态锁
state_lock = Lock()
# 人数计数器
people_count = 0

# ------------ 日志配置 ------------
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger()

# ------------ 网络配置 ------------
PC_IP = '192.168.1.166'  # PC端IP地址，根据实际情况修改
VIDEO_PORT = 5002
ALARM_PORT = 5003
THRESHOLD_PORT = 5004

# ------------ 视频配置 ------------
VIDEO_WIDTH = 640
VIDEO_HEIGHT = 480
FRAME_RATE = 10  # 降低帧率适配龙芯性能
DETECT_INTERVAL = 1  # 检测间隔

# ======================== 高精度人数识别系统 ========================
class OptimizedPeopleCounter:
    def __init__(self):
        # 人体尺寸过滤参数
        self.min_person_height = 100   # 最小人体高度（根据摄像头高度调整）
        self.max_person_height = 280   # 最大人体高度
        self.min_width_ratio = 0.3     # 宽高比下限
        self.max_width_ratio = 0.7      # 宽高比上限
        self.min_contour_area = 1500   # 最小轮廓面积
        
        # 跟踪参数
        self.tracked_persons = {}       # 跟踪字典 {id: {"centroid": (x,y), "disappeared": 0}}
        self.next_id = 0
        self.max_disappeared = 5       # 消失帧数阈值
        self.merge_threshold = 40      # 轮廓合并距离阈值（单位：像素）

    def merge_close_contours(self, contours):
        """合并距离过近的轮廓（解决一个人被识别成多人的问题）"""
        if not contours:
            return []
        
        # 计算所有轮廓的中心点
        centers = []
        valid_contours = []
        for contour in contours:
            # 过滤小轮廓
            if cv2.contourArea(contour) < 500:
                continue
                
            M = cv2.moments(contour)
            if M["m00"] > 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                centers.append((cx, cy))
                valid_contours.append(contour)
        
        # 如果没有有效轮廓，返回空列表
        if not centers:
            return []
        
        # 创建轮廓分组
        clusters = []
        used = [False] * len(centers)
        
        for i in range(len(centers)):
            if not used[i]:
                # 创建一个新簇
                cluster = [valid_contours[i]]
                used[i] = True
                
                # 查找邻近轮廓
                for j in range(i + 1, len(centers)):
                    if not used[j]:
                        # 计算距离
                        distance = np.sqrt((centers[i][0] - centers[j][0])**2 + 
                                          (centers[i][1] - centers[j][1])**2)
                        
                        if distance < self.merge_threshold:
                            cluster.append(valid_contours[j])
                            used[j] = True
                
                clusters.append(cluster)
        
        # 合并每个簇的轮廓
        merged_contours = []
        for cluster in clusters:
            # 合并所有轮廓点
            merged_points = np.vstack(cluster)
            
            # 获取凸包
            hull = cv2.convexHull(merged_points)
            merged_contours.append(hull)
        
        return merged_contours

    def update_tracking(self, rects):
        """基于质心跟踪的人数计数（解决瞬时分体问题）"""
        current_ids = []
        
        # 遍历检测到的所有矩形
        for rect in rects:
            (x, y, w, h) = rect
            cx = int(x + w/2)
            cy = int(y + h/2)
            
            # 计算矩形区域的中心点
            centroid = (cx, cy)
            
            # 尝试匹配现有跟踪对象
            min_dist = float("inf")
            matched_id = None
            
            for (id, person) in self.tracked_persons.items():
                # 检查是否在最大允许位移范围内
                distance = np.sqrt((centroid[0] - person["centroid"][0])**2 +
                                  (centroid[1] - person["centroid"][1])**2)
                
                if distance < min_dist and distance < 100:  # 限制最大位移
                    min_dist = distance
                    matched_id = id
            
            if matched_id is not None:
                # 更新现有跟踪对象
                self.tracked_persons[matched_id]["centroid"] = centroid
                self.tracked_persons[matched_id]["disappeared"] = 0
                current_ids.append(matched_id)
            else:
                # 创建新的跟踪对象
                self.tracked_persons[self.next_id] = {
                    "centroid": centroid,
                    "disappeared": 0
                }
                current_ids.append(self.next_id)
                self.next_id += 1
        
        # 检查消失的对象
        disappeared_ids = []
        for id in list(self.tracked_persons.keys()):
            if id not in current_ids:
                self.tracked_persons[id]["disappeared"] += 1
                
                if self.tracked_persons[id]["disappeared"] > self.max_disappeared:
                    disappeared_ids.append(id)
        
        # 移除消失的对象
        for id in disappeared_ids:
            del self.tracked_persons[id]
        
        return len(self.tracked_persons)  # 返回当前跟踪的人数

    def detect_persons(self, frame, fg_mask):
        """优化的人体检测方法"""
        # 轮廓检测
        result = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = result[0] if len(result) == 2 else result[1]
        
        # 轮廓合并（关键优化）
        merged_contours = self.merge_close_contours(contours)
        
        # 过滤有效人体区域
        person_rects = []
        for contour in merged_contours:
            # 获取边界矩形
            x, y, w, h = cv2.boundingRect(contour)
            
            # 面积过滤
            area = w * h
            if area < self.min_contour_area:
                continue
                
            # 宽高比过滤
            aspect_ratio = w / float(h)
            if not (self.min_width_ratio < aspect_ratio < self.max_width_ratio):
                continue
                
            # 高度过滤
            if h < self.min_person_height or h > self.max_person_height:
                continue
                
            person_rects.append((x, y, w, h))
            
            # 在帧上绘制矩形
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
        
        # 使用跟踪器更新人数计数
        count = self.update_tracking(person_rects)
        
        # 显示计数
        cv2.putText(frame, f"Count: {count}", (10, 30), 
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        
        return frame, count

# 使用优化的人数检测器
people_counter = OptimizedPeopleCounter()

# ======================== 摄像头与网络功能 ========================
def initialize_camera():
    """更健壮的摄像头初始化函数"""
    global cap
    
    logger.info("尝试打开摄像头...")
    max_attempts = 5
    
    for i in range(max_attempts):
        try:
            # 尝试不同的视频源索引
            for idx in range(0, 3):
                cap = cv2.VideoCapture(idx)
                if cap.isOpened():
                    logger.info(f"使用视频源索引: {idx}")
                    break
            
            if not cap.isOpened():
                logger.warning(f"摄像头打开失败，尝试 {i+1}/{max_attempts}")
                time.sleep(1)
                continue
            
            # 设置分辨率（适配龙芯性能）
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, VIDEO_WIDTH)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, VIDEO_HEIGHT)
            
            # 尝试设置帧率
            try:
                cap.set(cv2.CAP_PROP_FPS, FRAME_RATE)
            except:
                logger.warning("CAP_PROP_FPS属性不支持，将使用默认帧率")
            
            logger.info(f"摄像头成功打开，分辨率: {VIDEO_WIDTH}x{VIDEO_HEIGHT}")
            return True
            
        except Exception as e:
            logger.error(f"摄像头初始化异常: {str(e)}")
            if cap:
                cap.release()
            time.sleep(1)
    
    logger.error("无法打开摄像头，尝试所有方案失败")
    return False

def connect_to_pc(ip, port, sock_type, retries=10):
    """健壮的网络连接函数"""
    for attempt in range(1, retries + 1):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            
            logger.info(f"尝试连接到PC端 {sock_type} 端口: {ip}:{port}, 尝试 {attempt}/{retries}")
            sock.connect((ip, port))
            logger.info(f"成功连接到PC端 {sock_type} 端口")
            return sock
        except (socket.timeout, socket.error, ConnectionRefusedError) as e:
            logger.warning(f"{sock_type} 连接失败 ({e.__class__.__name__}): {str(e)}")
            time.sleep(3)
        except Exception as e:
            logger.error(f"{sock_type} 连接过程中出现意外错误: {str(e)}")
            time.sleep(3)
    
    logger.error(f"无法连接到PC端 {sock_type} 端口: {ip}:{port}")
    return None

# ======================== 图像处理优化 ========================
def process_frame(frame):
    """图像预处理 - 针对UVC摄像头优化"""
    # 转换为灰度图（性能优化）
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # 直方图均衡化（增强对比度）
    gray = cv2.equalizeHist(gray)
    
    # 高斯模糊减少噪声
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    
    return blur

# ======================== 安全退出处理 ========================
def cleanup():
    """清理资源"""
    logger.info("清理资源")
    if cap and cap.isOpened():
        cap.release()
        logger.info("摄像头已释放")
    
    if video_sock:
        video_sock.close()
        logger.info("视频套接字已关闭")
    
    if alarm_sock:
        alarm_sock.close()
        logger.info("报警套接字已关闭")
    
    if threshold_sock:
        threshold_sock.close()
        logger.info("阈值套接字已关闭")
    
    cv2.destroyAllWindows()
    logger.info("程序已安全退出")

atexit.register(cleanup)

# ======================== 视频流发送功能 ========================
def send_video_stream():
    global video_sock, frame_counter, people_count, cap
    
    # 创建健壮的连接
    video_sock = connect_to_pc(PC_IP, VIDEO_PORT, "视频")
    if not video_sock:
        logger.error("无法建立视频连接，视频发送中止")
        return
    
    # 背景减法器 - 针对UVC摄像头优化
    bg_subtractor = cv2.createBackgroundSubtractorMOG2(history=100, varThreshold=25, detectShadows=False)
    
    # 形态学操作内核（根据摄像头特性调整）
    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    kernel_close = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (11, 11))
    
    # 确保摄像头已打开
    if cap is None or not cap.isOpened():
        if not initialize_camera():
            logger.error("摄像头初始化失败，视频发送中止")
            return
    
    logger.info("开始视频流传输")
    
    last_time = time.time()
    frame_skip = 0  # 跳帧计数器
    frame_interval = 3  # 每3帧处理1次（性能优化）
    
    while True:
        try:
            ret, frame = cap.read()
            if not ret:
                logger.warning("无法从摄像头获取帧，尝试重新初始化...")
                cap.release()
                if not initialize_camera():
                    time.sleep(1)
                continue
            
            frame_counter += 1
            frame_skip = (frame_skip + 1) % frame_interval
            
            # 性能优化：跳过部分帧处理
            if frame_skip != 0:
                continue
            
            # 1. 应用背景减法获取运动区域
            fg_mask = bg_subtractor.apply(frame)
            
            # 2. 二值化处理
            _, fg_mask = cv2.threshold(fg_mask, 200, 255, cv2.THRESH_BINARY)
            
            # 3. 形态学操作（优化解决断裂问题）
            # 先进行开运算去除噪声
            fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel_open)
            # 再进行闭运算连接区域（关键优化点）
            fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_CLOSE, kernel_close)
            
            # 4. 使用优化的人体检测算法
            try:
                frame, people_count = people_counter.detect_persons(frame, fg_mask)
            except Exception as e:
                logger.error(f"人数检测错误: {str(e)}")
                people_count = 0
            
            # 5. 压缩并发送帧
            encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 70]  # 降低质量提高性能
            ret, img_encoded = cv2.imencode('.jpg', frame, encode_param)
            if not ret:
                logger.error("图像编码失败，跳过此帧")
                continue
                
            data = img_encoded.tobytes()
            
            # 创建帧头: 帧大小 + 帧号 + 当前人数
            header = struct.pack("!III", len(data), frame_counter, people_count)
            
            try:
                # 发送帧头 + 帧数据
                video_sock.sendall(header)
                video_sock.sendall(data)
                
                # 限速发送（控制帧率）
                elapsed = time.time() - last_time
                sleep_time = max(0, (1.0 / FRAME_RATE) - elapsed)
                time.sleep(sleep_time)
                last_time = time.time()
                
                # 日志记录（调试）
                if frame_counter % 10 == 0:
                    logger.info(f"发送帧 {frame_counter}，人数: {people_count}")
                
            except (socket.error, BrokenPipeError, ConnectionResetError) as e:
                # 网络中断处理
                logger.error(f"视频发送错误: {e.__class__.__name__} - {str(e)}")
                logger.info("尝试重新连接...")
                
                # 关闭旧socket并重新连接
                try:
                    video_sock.close()
                except:
                    pass
                    
                video_sock = connect_to_pc(PC_IP, VIDEO_PORT, "视频")
                if not video_sock:
                    logger.error("重连失败，停止视频发送")
                    return
                    
                time.sleep(1)  # 避免过快重试
            
        except Exception as e:
            logger.error(f"视频处理错误: {e.__class__.__name__} - {str(e)}")
            time.sleep(1)

# ======================== 报警处理功能 ========================
def handle_alarm():
    global alarm_sock, alarm_active, alarm_type, people_count
    
    # 创建健壮的连接
    alarm_sock = connect_to_pc(PC_IP, ALARM_PORT, "报警")
    if not alarm_sock:
        logger.error("无法建立报警连接，报警发送中止")
        return
    
    logger.info("启动报警处理线程")
    
    while True:
        try:
            with state_lock:
                if alarm_active:
                    # 生成报警信息
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                    alarm_data = f"{timestamp},{alarm_type},{people_count}".encode()
                    
                    # 发送报警数据
                    try:
                        # 先发送数据长度
                        size = struct.pack("!I", len(alarm_data))
                        alarm_sock.sendall(size)
                        
                        # 再发送实际数据
                        alarm_sock.sendall(alarm_data)
                        
                        logger.info(f"已发送报警: {alarm_type} ({people_count})")
                        
                        # 重置报警状态
                        alarm_active = False
                        alarm_type = ""
                    except (socket.error, BrokenPipeError) as e:
                        logger.error(f"报警发送失败: {e}")
                        logger.info("尝试重新连接报警服务...")
                        
                        try:
                            alarm_sock.close()
                        except:
                            pass
                            
                        alarm_sock = connect_to_pc(PC_IP, ALARM_PORT, "报警")
                        if not alarm_sock:
                            logger.error("重连失败，停止报警处理")
                            return
                        
                        # 重新发送报警（不重置状态）
                        continue
            
            # 合理休眠避免CPU占用过高
            time.sleep(0.5)
            
        except Exception as e:
            logger.error(f"报警处理错误: {e.__class__.__name__} - {str(e)}")
            time.sleep(1)

# ======================== 阈值接收功能 ========================
def receive_threshold():
    global threshold_sock, alarm_threshold_upper, alarm_threshold_lower
    
    # 创建监听套接字
    threshold_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    threshold_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        threshold_sock.bind(('0.0.0.0', THRESHOLD_PORT))
        threshold_sock.listen(5)
        threshold_sock.settimeout(3.0)
        logger.info(f"阈值接收服务启动, 监听端口: {THRESHOLD_PORT}")
        
        while True:
            try:
                conn, addr = threshold_sock.accept()
                logger.info(f"接收到阈值连接: {addr}")
                
                try:
                    data = conn.recv(1024)
                    if data:
                        try:
                            thresholds = data.decode().split(',')
                            if len(thresholds) != 2:
                                raise ValueError("阈值数据格式错误")
                                
                            new_upper = int(thresholds[0])
                            new_lower = int(thresholds[1])
                            
                            # 使用锁保护全局状态
                            with state_lock:
                                if new_lower < new_upper:
                                    alarm_threshold_upper = new_upper
                                    alarm_threshold_lower = new_lower
                                    logger.info(f"更新阈值: 上限={alarm_threshold_upper}, 下限={alarm_threshold_lower}")
                                else:
                                    logger.warning(f"无效阈值: 下限{new_lower}不应大于或等于上限{new_upper}")
                        except Exception as e:
                            logger.warning(f"解析阈值失败: {str(e)}")
                except Exception as e:
                    logger.error(f"接收阈值数据错误: {str(e)}")
                finally:
                    try:
                        conn.close()
                    except:
                        pass
                    
            except socket.timeout:
                pass  # 正常超时，继续循环
            except Exception as e:
                logger.error(f"接受连接错误: {str(e)}")
                time.sleep(1)
                
    except Exception as e:
        logger.error(f"阈值服务启动失败: {str(e)}")
        return
    finally:
        try:
            threshold_sock.close()
        except:
            pass

# ======================== 报警检测功能 ========================
def detect_alarm():
    global alarm_active, alarm_type, people_count
    
    logger.info("启动报警检测线程")
    
    while True:
        try:
            with state_lock:
                if people_count > alarm_threshold_upper:
                    if not alarm_active or alarm_type != "OVER":
                        alarm_active = True
                        alarm_type = "OVER"
                        logger.warning(f"触发上限报警: {people_count}>{alarm_threshold_upper}")
                elif people_count < alarm_threshold_lower:
                    if not alarm_active or alarm_type != "UNDER":
                        alarm_active = True
                        alarm_type = "UNDER"
                        logger.warning(f"触发下限报警: {people_count}<{alarm_threshold_lower}")
            
            # 合理休眠
            time.sleep(1)
            
        except Exception as e:
            logger.error(f"报警检测错误: {e.__class__.__name__} - {str(e)}")
            time.sleep(2)

# ======================== 主程序 ========================
if __name__ == "__main__":
    # 首先初始化摄像头
    if not initialize_camera():
        logger.error("无法打开摄像头，程序退出")
        sys.exit(1)
        
    logger.info("启动工业安防监控系统(设备端)")
    logger.info(f"目标PC: {PC_IP}")
    
    # 启动各个线程
    threads = [
        Thread(target=send_video_stream, name="VideoStream", daemon=True),
        Thread(target=handle_alarm, name="AlarmHandler", daemon=True),
        Thread(target=receive_threshold, name="ThresholdReceiver", daemon=True),
        Thread(target=detect_alarm, name="AlarmDetector", daemon=True)
    ]
    
    for t in threads:
        t.start()
    
    logger.info("所有服务线程已启动")
    
    # 主线程保持运行
    try:
        while True:
            time.sleep(5)
            logger.info(f"系统运行中... 当前人数: {people_count}")
    except KeyboardInterrupt:
        logger.info("检测到中断信号，正在关闭...")
    finally:
        cleanup()
        sys.exit(0)


