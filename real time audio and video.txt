#!/usr/bin/env python3
# sender.py - 龙芯板音视频发送端（优化版）
import cv2
import socket
import time
import numpy as np
import logging
import subprocess
import sys
import threading
import os

# ============== 配置区域 ==============
TARGET_IP = "192.168.1.166"  # 接收端PC的实际IP地址
VIDEO_PORT = 5002
AUDIO_PORT = 5003
VIDEO_FRAME_WIDTH = 640
VIDEO_FRAME_HEIGHT = 480
VIDEO_FPS = 15                 # 目标帧率（根据需求调整）
AUDIO_SAMPLE_RATE = 44100      # 音频采样率
AUDIO_CHANNELS = 1            # 音频通道数
# =====================================

class MediaStreamer:
    def __init__(self):
        # 状态控制
        self.active = True
        
        # 网络套接字
        self.video_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.audio_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.video_socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 10 * 1024 * 1024)
        
        # 视频性能计数器
        self.frame_count = 0
        self.start_time = time.time()
        
        # 配置日志
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S',
            handlers=[logging.StreamHandler(sys.stdout)]
        )
        
        # 初始化摄像头
        self.cap = self.initialize_camera()
        
        # 初始化音频
        self.audio_process = None
        
        logging.info("✅ 发送端初始化完成")

    def initialize_camera(self):
        """初始化摄像头并设置参数"""
        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            logging.error("❌ 无法打开摄像头，创建虚拟源")
            return self.create_virtual_camera()
            
        # 尝试设置分辨率
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, VIDEO_FRAME_WIDTH)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, VIDEO_FRAME_HEIGHT)
        
        # 打印实际分辨率
        actual_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
        actual_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
        logging.info(f"📷 摄像头分辨率: {int(actual_width)}x{int(actual_height)}")
        
        return cap

    def create_virtual_camera(self):
        """创建虚拟摄像头"""
        class VirtualCamera:
            def __init__(self):
                self.frame_count = 0
                
            def read(self):
                img = np.zeros((VIDEO_FRAME_HEIGHT, VIDEO_FRAME_WIDTH, 3), dtype=np.uint8)
                cv2.putText(img, "Virtual Camera", 
                           (50, VIDEO_FRAME_HEIGHT//2 - 20), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                cv2.putText(img, "Press 'q' to quit", 
                           (50, VIDEO_FRAME_HEIGHT//2 + 30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 1)
                self.frame_count += 1
                return True, img
                
            def isOpened(self):
                return True
                
            def release(self):
                pass
        
        return VirtualCamera()

    def start_audio_capture(self):
        """启动ALSA音频采集"""
        try:
            # 检查arecord是否可用
            subprocess.check_call(["arecord", "--version"], 
                                 stdout=subprocess.DEVNULL, 
                                 stderr=subprocess.DEVNULL)
            
            # 构建arecord命令
            cmd = [
                "arecord",
                "-f", "S16_LE",      # 16位小端格式
                "-r", str(AUDIO_SAMPLE_RATE),
                "-c", str(AUDIO_CHANNELS),
                "-t", "raw",         # 原始格式
                "-"                  # 输出到stdout
            ]
            
            # 启动音频采集进程
            self.audio_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            logging.info(f"🎙️ 音频采集已启动 @ {AUDIO_SAMPLE_RATE}Hz")
            
            # 启动音频发送线程
            audio_thread = threading.Thread(target=self.audio_sending_thread)
            audio_thread.daemon = True
            audio_thread.start()
            
            return True
            
        except (FileNotFoundError, subprocess.CalledProcessError):
            logging.error("❌ arecord命令不可用，跳过音频采集")
            logging.info("请安装alsa-utils: sudo apt install alsa-utils")
            return False

    def audio_sending_thread(self):
        """音频发送线程"""
        logging.info("🔊 音频发送线程启动")
        audio_packet_size = 1024 * AUDIO_CHANNELS * 2  # 16位 * 通道数
        
        while self.active and self.audio_process.poll() is None:
            try:
                # 读取音频数据
                audio_data = self.audio_process.stdout.read(audio_packet_size)
                if audio_data:
                    self.audio_socket.sendto(audio_data, (TARGET_IP, AUDIO_PORT))
                else:
                    time.sleep(0.01)
            except Exception as e:
                logging.error(f"🔴 音频发送错误: {str(e)}")
                break

    def video_capture_thread(self):
        """视频捕获线程"""
        logging.info("📹 视频捕获线程启动")
        
        # 帧率控制变量
        frame_interval = 1.0 / VIDEO_FPS
        last_frame_time = time.time()
        
        while self.active:
            try:
                # 控制帧率
                current_time = time.time()
                sleep_time = max(0, last_frame_time + frame_interval - current_time)
                time.sleep(sleep_time)
                last_frame_time = current_time
                
                # 读取视频帧
                ret, frame = self.cap.read()
                if not ret:
                    logging.warning("⚠️ 读取帧失败，跳过")
                    continue
                
                # JPEG压缩（降低质量以减小带宽）
                _, img_encoded = cv2.imencode('.jpg', frame, [
                    int(cv2.IMWRITE_JPEG_QUALITY), 70
                ])
                
                # 发送视频数据
                self.video_socket.sendto(img_encoded.tobytes(), (TARGET_IP, VIDEO_PORT))
                
                # 更新帧计数
                self.frame_count += 1
                
                # 每秒显示帧率
                elapsed = time.time() - self.start_time
                if elapsed >= 1.0:
                    fps = self.frame_count / elapsed
                    logging.info(f"📹 视频帧率: {fps:.1f} FPS")
                    self.frame_count = 0
                    self.start_time = time.time()
                    
            except Exception as e:
                logging.error(f"🔴 视频捕获错误: {str(e)}")
                time.sleep(0.1)

    def start_streaming(self):
        """启动音视频流传输"""
        logging.info(f"🚀 目标地址: {TARGET_IP}:{VIDEO_PORT}(视频)/{AUDIO_PORT}(音频)")
        
        # 启动音频采集
        audio_started = self.start_audio_capture()
        
        # 启动视频线程
        video_thread = threading.Thread(target=self.video_capture_thread)
        video_thread.daemon = True
        video_thread.start()
        
        # 等待退出
        try:
            while self.active:
                time.sleep(1)
        except KeyboardInterrupt:
            self.active = False
        finally:
            self.cleanup()

    def cleanup(self):
        """资源清理"""
        self.active = False
        time.sleep(0.1)  # 给线程时间退出
        
        # 关闭摄像头
        if hasattr(self.cap, 'release'):
            try:
                self.cap.release()
            except:
                pass
        
        # 关闭音频进程
        if self.audio_process and self.audio_process.poll() is None:
            try:
                self.audio_process.terminate()
                self.audio_process.wait(timeout=1.0)
            except:
                pass
        
        # 关闭套接字
        self.video_socket.close()
        self.audio_socket.close()
        
        logging.info("✅ 资源已释放")

if __name__ == "__main__":
    try:
        streamer = MediaStreamer()
        streamer.start_streaming()
    except Exception as e:
        logging.error(f"🔴 程序异常: {str(e)}")


